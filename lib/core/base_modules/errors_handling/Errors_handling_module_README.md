   # Errors Handling Module Guide
*Last updated: 2025-08-05*

[![Flutter](https://img.shields.io/badge/Flutter-3.0+-blue.svg)](https://flutter.dev/)
[![Dart](https://img.shields.io/badge/Dart-3.0+-blue.svg)](https://dart.dev/)

   ## üéØ Goal 

>   Module was designed as a **enterprise-grade, platform-agnostic, modular, type-safe error handling system**
for Flutter apps with clean architecture codebase, declarative error flows and easy integration of overlays, localization, logging, additional chainable logic.
Currently it consist only a few FailureType erorrs (shown as an example), that easily can be extended by any specific FailureType


----------------------------------------------------------------

   ## üöÄ Quick Start

### 1. Integrate Error Handling Core

* Add `core_of_module/` and `extensible_part/` to your project.*
* No external dependencies on any state management package.

------------

### 2. Handle errors in 3 steps

* 1. - In Repository - wrap operations

```dart
@override
ResultFuture<UserEntity> getProfile({required String uid}) =>
  (() async => await _cacheManager.execute(uid, () => _fetchProfile(uid)))
  .runWithErrorHandling();
```

* 2. - In UseCase return Either, then in Presentation layer manage failures via chosen 
state manager and emit errors state in UI

```dart
final result = await getUserUseCase();
result.fold(
  (failure) => emit(UserError(failure.asConsumable())),
  (user) => emit(UserLoaded(user)),
);
// Auto-logging, localized messages, optional retry buttons, consistent UI
```

* 3. - Handle erors in via chosen UX pattern (e.g. via overlays)

**BLoC/Cubit specific usage:**
```dart
BlocListener<Cubit, State>(
  listenWhen: ..., 
  listener: (context, state) {
    final failure = state.failure?.consume(); // for guaranteeing one-shot feedback.
    if (failure != null) {
      final failureUIEntity = failure.toUIEntity();
      context.showError(failureUIEntity);
      ...
      context.read<Cubit>().clearFailure();
      ...
    }
  },
)
```

**Riverpod specific usage**
Uses `ref.listenFailure(failure.toUIEntity)` ‚Äî adaptive listener for failures.

```dart
 @override
  Widget build(BuildContext context, WidgetRef ref) {
    // ‚ùóÔ∏è Listen and display any async errors as overlays
    ref.listenFailure(profileProvider(uid), context);
    ...

// where:
extension FailureListenerRefX on WidgetRef {
  void listenFailure<T>(
    ProviderListenable<AsyncValue<T>> provider,
    BuildContext context, {
    ListenFailureCallback? onFailure,
  }) {
    listen<AsyncValue<T>>(provider, (prev, next) {
      final failure = next.asFailure;
      if (failure != null) {
        final failureUIEntity = failure.toUIEntity();
        context.showError(failureUIEntity);
      }
    });
  }
}


```



* That's it!*

   **Also**:
- ‚úÖ Errors are automatically mapped from exceptions to domain failures
- ‚úÖ Every public method returns `ResultFuture<T> = Future<Either<Failure, T>>`.
- ‚úÖ Avaiable aditional logic, logging to console/crashlytics  
- ‚úÖ Automatical localization via `translationKey` in `FailureType` (see `failure_type.dart`)




----------------------------------------------------------------

   ## üß© Errors Handling Flow

   ### High-Level Flow
1. * Exceptions or Failures originate strictly in the data layer. 
     All unexpected errors are thrown only in Data layer.
2. * Exception mapping to Failure. 
     In Repos, exceptions are mandatory mapps to domain-level `Failure` via `.mapToFailure()` (see `_exceptions_to_failures_mapper_x`).
3. * Returning Failure as Either
     All repository methods return `Either<Failure, T>`; no exceptions are leaked.
4. * Failure mapped to FailureUIEntity
     Via `.toUIEntity()` Ffor all overlays, dialogs, and user feedback.
5. **Display in UI layer**
   * **Riverpod:** Call `ref.listenFailure` in the widget tree ‚Äî overlays/dialogs are handled automatically.
   * **Cubit/BLoC:** Use `Consumable<FailureUIEntity>`, `BlocListener`, and `context.showError(failure.toUIEntity)`.
6. **Optional Chainable DSL, Logging, Analytics**
   ‚Äî Use (if needed) chainable error handlers or built-in extensions: `.log()`, analytics, diagnostics, and custom hooks.

------

## üèóÔ∏è Architecture Overview

```mermaid
graph TD
    A[Exception/Error] -->|mapToFailure()| B[Failure]
    B -->|toUIEntity()| C[FailureUIEntity]
    C -->|context.showError()| D[User Sees Dialog]
    
    E[DataSource] -->|throws| F[Repository]
    F -->|Either<Failure,T>| G[UseCase]
    G -->|Either<Failure,T>| H[StateManager]
    H -->|Consumable<Failure>| I[UI]
```


   ### Example: Error-Driven Flow (Profile Feature)
```
DataSourceImpFile:   Throws exception for unknow flow or Failures for handled cases
  ‚Üì
RepoImpFile:         Exceptions catches and maps to Failure via `.mapToFailure()`, 
  ‚Üì                  Failures pass through, so RepoImpFile returns Either<Failure, T> to UseCase
  ‚Üì
UseCaseFile:         Propagates Either<Failure, T>  to State manager
  ‚Üì
State manager:       Emits error state with Failure
  ‚Üì 
UI (error listener)  Failure mapps to FailureUIEntity `failure.toUIEntity()`
  ‚Üì
                     UI observes and displays overlay/dialog via one-shot (consumable) pattern
```


   ### Example: UI-Driven Flow
```
User triggers action
  ‚Üì
State manager (Cubit/Notifier) calls UseCase
  ‚Üì
UseCase delegates to Repository
  ‚Üì
Repository calls DataSource, get result (Either or throws)
  ‚Üì
THEN 
     the same flow as in case of "error-driven case"
```


----------------------------------------------------------------

   ## üß± Layered Usage 

   ### üß© Core Error Handling Concepts

| Concept          | Purpose                                                                          |
| ---------------- | ---------------------------------------------------------------------------------|
| `Failure`        | Domain-level abstraction of error (not just Exception!)                          |
| `FailureUIEntity`| UI-ready error with icon & i18n (presentation model)                             |
| `Consumable<T>`  | Ensures feedback triggers only once (one-shot overlays etc.)                     |
| `.mapToFailure()`| Converts exceptions (SDK, platform, etc) ‚Üí structured Failure                    |
|-----------------------------------------------------------------------------------------------------|
| `Either<L, R>` -  Functional result wrapper: `Left` = Failure, `Right` = Success;                   |
|  immutable, declarative, enables pattern matching, chaining, and testable error flows               |
|-----------------------------------------------------------------------------------------------------|


   ### üß± Layered Responsibilities Table

| Layer          | Responsibilities                                                |
| -------------- | ------------------------------------------------------------------------------------------------ |
| DataSource     | Throws raw Exceptions or Either for handled flows     |
| Repository     | Converts to Either, maps Exception ‚Üí Failure  | Wraps via safeCall, uses FailureMapper, logs errors |
| UseCase        | Delegates business logic, returns Either      | Pure, stateless, no framework                       |
| StateManager   | Emits state, handles results                  | .fold or DSL for composite flows                    |
| UI Layer       | Shows overlay/feedback, listens to consumable | Triggers overlay only if .consume() is not null     |
| OverlayManager | Renders feedback centralized                  | Uses context.showError(FailureUIEntity)             |
-----------------------------------------------------------------------------------------------------------------------

### **Data Layer (Repository, DataSource):**

* **Central error boundary**, **No Exception leaves the data layer unconverted.**
All async operations are wrapped (be **runWithErrorHandling():**) here, mapping all exceptions to `Failure`.

   




-------------------

   ## **Explicit (classic) Either Style** VS **DSL-like Style** in STATE manager  

   This module supports two alternative paradigms:

   - üß® **Either** ‚Äî Classic, explicit and readable error flow using `Either<Failure, T>` and `.fold(...)`
Suits for simple cases ( `.fold((f) => emit(Error(f)), (v) => emit(Success(v)))`. )

   - üîó **DSL-like** ‚Äî Declarative, chainable alternative inspired by functional programming, using `ResultHandler`, `.match()` and `.matchAsync()` extensions
Suits for complex cases with additional logic (includiing logs, side effects) with DSL-style handler (`ResultHandler`) for chaining.

Examples:
```dart


// **DSL-like** ‚Äî Declarative, chainable alternative inspired by functional programming
await getUserUseCase().then(
  (r) => ResultHandler(r)
    ..onFailure((f) => emit(ErrorState(f)))
    ..onSuccess((v) => emit(SuccessState(v)))
    ..log(),
);
```

-------------------

### Either: Explicit (Classic) Style

‚úÖ When to Use:
- You want **full control** over success and failure handling
- You prefer **clarity** and **predictable flow**
- Common in Cubit/BLoC/Riverpod state management

ü§© Code Example:
```dart
final result = await someUseCase();
// Classic, explicit and readable error flow
result.fold(
  (failure) => emit(ErrorState(failure)),
  (data) => emit(SuccessState(data)),
);
```

-------------------

### üßö DSL-like Style

‚úÖ When to Use:
- You prefer a **chainable API** with fluent handlers
- You want to reduce boilerplate (fold logic repeated often)
- Great for services, reactive flows, or advanced orchestration

#### ‚ú≥Ô∏è A few variants of usage:

* 1. `matchAsync()` Extension:
```dart
await getUserUseCase().matchAsync(
  onFailure: (f) => emit(Failed(f)),
  onSuccess: (u) => emit(Loaded(u)),
);
```

* 2. DSLLike `ResultHandler`:
```dart
await getUserUseCase().then((r) => ResultHandler(r)
  .onFailure((f) => emit(Failed(f)))
  .onSuccess((u) => emit(Loaded(u))));
```

* 3. `match()` (sync style for `Either<Failure, T>`):
```dart
final result = await getUserUseCase();
result.match(
  onFailure: (f) => emit(Failed(f)),
  onSuccess: (u) => emit(Loaded(u)),
);
```

#### ‚ú® Avaiable Advanced Chaining:
```dart
await getUserUseCase()
  .flatMapAsync((u) => checkAccess(u))
  .recover((f) => getGuestUser())
  .mapRightAsync((u) => saveLocally(u))
  .then((r) => ResultHandler(r).log());
```




----------------------------------------------------------------

   ## üß© Files structure of module

``` plaintext
errors_handling/
.
‚îú‚îÄ‚îÄ core_of_module
|   |
‚îÇ   ‚îú‚îÄ‚îÄ _run_errors_handling.dart
‚îÇ   ‚îú‚îÄ‚îÄ either.dart
‚îÇ   ‚îú‚îÄ‚îÄ failure_entity.dart
‚îÇ   ‚îú‚îÄ‚îÄ failure_type.dart
‚îÇ   ‚îú‚îÄ‚îÄ failure_ui_entity.dart
‚îÇ   ‚îú‚îÄ‚îÄ failure_ui_mapper.dart
|   |
‚îÇ   ‚îî‚îÄ‚îÄ core_utils
‚îÇ       ‚îú‚îÄ‚îÄ errors_observing
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ loggers
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ crash_analytics_logger.dart
‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ errors_log_util.dart
‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ failure_logger_x.dart
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ result_loggers
‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ async_result_logger.dart
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ result_logger_x.dart
‚îÇ       ‚îú‚îÄ‚îÄ extensions_on_either
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ either__facade.dart
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ either__x.dart
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ either_async_x.dart
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ either_getters_x.dart
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ for_tests_either_x.dart
‚îÇ       ‚îú‚îÄ‚îÄ extensions_on_failure
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ failure_to_either_x.dart
‚îÇ       ‚îú‚îÄ‚îÄ specific_for_bloc
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ consumable_extensions.dart
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ consumable.dart
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ result_handler_async.dart
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ result_handler.dart
‚îÇ       ‚îî‚îÄ‚îÄ specific_for_riverpod
‚îÇ           ‚îî‚îÄ‚îÄ show_dialog_when_error_x.dart
|
‚îú‚îÄ‚îÄ extensible_part
|   |
‚îÇ   ‚îú‚îÄ‚îÄ exceptions_to_failure_mapping
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _exceptions_to_failures_mapper_x.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dio_exceptions_mapper.dart
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ firebase_exceptions_mapper.dart
|   |
‚îÇ   ‚îú‚îÄ‚îÄ failure_extensions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ failure_diagnostics_x.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ failure_icons_x.dart
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ failure_led_retry_x.dart
|   |
‚îÇ   ‚îî‚îÄ‚îÄ failure_types
‚îÇ       ‚îú‚îÄ‚îÄ _failure_codes.dart
‚îÇ       ‚îú‚îÄ‚îÄ firebase.dart
‚îÇ       ‚îú‚îÄ‚îÄ misc.dart
‚îÇ       ‚îî‚îÄ‚îÄ network.dart
|
‚îú‚îÄ‚îÄ docs
‚îî‚îÄ‚îÄ Errors_handling_module_README.md

```


----------------------------------------------------------------

   ## ‚ùì FAQ & Troubleshooting

* **How do I add a new Failure type?**
  * Add to `extensible_part/failure_types/` and reference in your mappers.

* **How do I map Dio/Firebase/other exceptions?**
  * Use mappers in `extensible_part/exceptions_to_failure_mapping/`.

* **How do I display overlays/dialogs in Riverpod?**
  * Use `ref.listenFailure(yourProvider, context)`.

* **How do I display overlays in Cubit/BLoC?**
  * Emit `Consumable<FailureUIEntity>`, BlocListener, `context.showError(error)`.

* **How do I log or report errors?**
  * Use `failure.log()`, `failure.logCrashAnalytics()`, or a custom logger.

* **How do I test error flows and overlays?**
  * Use Either or the `.forTests` extension for test flows.

* **How do I add Retry logic?**
  * Expose `canRetry` and a retry handler in Failure or FailureUIEntity.

* **How do I customize error visuals/icons?**
  * Extend `FailureIconsX` or your own UI mappers.

* **Can I use the pipeline in pure Dart/tests/CLI?**
  * Yes, everything except overlay/UI integrations.

* **What is `Consumable<T>`?**
A one-time value wrapper for UI side effects, that:
      - Guarantees one-shot overlays/dialogs
      - Prevents duplicate feedback on rebuilds
      - Declarative and easily testable

* When/Which to choose between **Either (classic)** and **DSL-like** code styles

| ‚úÖ Criteria                      | Either (Classic)| DSL-like Handler     |
| ---------------------------------|----------------|-----------------------|
| ‚úÖ Predictable and explicit      | ‚úîÔ∏è Yes          | ‚ùå Less explicit      |
| ‚úÖ Declarative & chainable       | ‚ùå No           | ‚úîÔ∏è Yes                |
| ‚úÖ Requires no extra wrappers    | ‚úîÔ∏è Yes          | ‚ùå Needs `.then(...)` |
| ‚úÖ Team prefers functional style | ‚ùå Maybe        | ‚úîÔ∏è Perfect fit        |

> üß† **Recommendation:** Use Either by default for UI state management. DSL-style is best for expressive chains and functional flows.




   ### üõ† Troubleshooting

* **Overlay/dialog not shown in Riverpod:**
  * Use `ref.listenFailure(yourProvider, context)`.

* **Overlay/dialog not shown in Cubit/BLoC:**
  * Use BlocListener, emit `Consumable<FailureUIEntity>`, call `context.showError(...)`.

* **Failure is always generic:**
  * Check your mappers in `exceptions_to_failure_mapping/`.

* **Retry button does not appear:**
  * Ensure `canRetry = true` and provide a retry handler.

* **No logging:**
  * Use `failure.log()` or loggers from `errors_observing/loggers/`.

* **UI shows raw error or stacktrace:**
  * Always map with `toUIEntity()` and display via overlay/dialog.


   ## üß≠ Decision Matrix

| Context                 | Strategy                   | Rationale                               |
| ----------------------- | -------------------------- | --------------------------------------- |
| Complex UX flows        | ResultHandler              | Fluent, side effects, fallback, retry   |
| Simple flows            | .fold() / .match()         | Readable, concise                       |
| SDK/API errors          | ASTRODES throw             | Thrown, mapped to Failure in repo       |
| Domain failures         | Either                     | As-is, no throwing                      |
| Consistent result shape | ResultFuture<T>            | Standardized async everywhere           |
| Exception handling      | safeCall() extension       | Centralizes all error mapping           |
| Failure-to-UI           | .toUIEntity()              | UI-ready error with icons, i18n         |
| UI trigger              | context.showError()        | Declarative, one point for all overlays |
| One-time feedback       | Consumable<FailureUIEntity>| Prevents duplicate overlays             |



----------------------------------------------------------------

   ## ‚ö°Ô∏è Best Practices

* **Use only Failure as the error source** ‚Äî never expose raw Exception or strings in public APIs.
* **Map all exceptions to Failure ASAP** via `.mapToFailure()`.
* **Isolate mapping logic** for 3rd-party exceptions (dio, firebase, etc.) in dedicated files.
* **Never display raw errors inline in widgets** ‚Äî always use overlays/dialogs via provided extensions.
* **For Cubit/BLoC:** Always use `Consumable<FailureUIEntity>` for one-shot overlays.
* **For Riverpod:** Always attach `ref.listenFailure` in your widgets.
* **Log all errors via provided extensions** (`failure.log()`) before reporting or displaying.
* **Test all error flows using functional result types (Either) or pure Dart logic.**
* **Avoid coupling error handling with business/state/UI logic:** keep overlays, mapping, and logging separate.
* **Add new failure types/extensions in `extensible_part/`.**
* **Document custom mappings or overlays for your team.**



----------------------------------------------------------------

 ## ‚úÖ Final Notes

---

### üèÜ **Key Principles**

- ü¶æ **Universal & State-Agnostic**  
  Seamlessly works with Riverpod, Cubit/BLoC, or pure Dart ‚Äî zero vendor lock-in.

- üí™ **Optimized for real-world teams & codebases**  
  Suitable for projects of any size or complexity. 

- ‚ö°Ô∏è **Decoupled Error Flow**  
  Mapping, logging, UI overlays, and retry logic are modular and isolated.  

- üîí **Strictly type-safe & future-proof**  
  No raw exceptions or magic strings leak outside the data layer. 

- üß© **Single Source of Truth**  
  All domain-errors are modeled as `Failure`, UI errors - as `FailureUIEntity`, enforcing clean boundaries. 

- üìê **Clean Architecture by Design**  
  Each layer (DataSource, Repository, UseCase, StateManager, UI) has a clear, decoupled responsibility.


---


### üí° **Benefits**

- üßë‚Äçüíª **Collaboration-Ready**  
  Explicit contracts and clear boundaries make onboarding and teamwork effortless.  
- üìö **Self-Documenting & Discoverable**  
  Flows, extensions, and usage are easily found and understood via intuitive docs and naming.  
- üîÑ **Easy Refactoring & Maintenance**  
  Change or extend any layer with confidence; no hidden coupling or side effects.  
- üö¶ **Safe by Default**  
  Every error is either surfaced to the user or logged/tracked ‚Äî never lost.  
- ‚è≥ **Minimal Boilerplate**  
  Declarative patterns let teams focus on features, not glue spaghetti code.



> **Build robust, scalable Flutter apps with declarative error handling and architecture-first philosophy.**  
> Your error handling will remain robust and maintainable ‚Äî no matter how fast your product or team grows.

üß™ Happy error handling & bulletproof code! ‚òïÔ∏è


----------------------------------------------------------------